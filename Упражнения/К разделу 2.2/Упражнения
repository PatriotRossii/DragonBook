# Упражнения к разделу 2.2

## Упражнение 2.2.1

> Рассмотрим контекстно-свободну грамматику
> S → S S + | S S * | a
> а) Покажите, как данная грамматика генерирует строку aa+a*.
> б) Постройте дерево разбора для данной строки.
> в) Какой язык генерирует данная грамматика? Обоснуйте свой ответ

а)
* a; S = a
* aa+; S = S S +
* aa+a*; S = S S *

б) Смотри приложение «Схема к упражнению 2.2.1»

в) Данная грамматика формирует язык, состоящий из строк «a» или «aa», разделенных (справа) знаками плюс или звездочкой.

## Упражнение 2.2.2

> Какой язык генерируется каждой из следующих грамматик? В каждом случае обоснуйте свой ответ

> а) S → 0 S 1 | 0 1

Данная грамматика генерирует язык, состоящий из n нулей и следующих за ними n единиц.

> б) S → + S S | - S S | a

Данная грамматика формирует язык, состоящий из строк «a» или «aa», разделенных (слева) знаками плюс или минус.

> в) S → S (S) S | epsilon

Данная грамматика формирует правильную скобочную последовательность.

> г) S → a S b S | b S a S | epsilon

Данная грамматика формирует строки, состоящие из букв a или b (или же пустую строку)

> Д) S → a | S + S | S S | S* | (S)

Данная грамматика генерирует язык, состоящий из строк, состоящих из буквы «a» произвольной длины, возможно заканчивающихся звездочкой, разделенных плюсами и возможно заключенных в скобки (сколь угодно вложенно)

## Упражнение 2.2.3

Неоднозначны грамматики в, д

## Упражнение 2.2.4

> Постройте однозначные контекстно-свободные грамматики для каждого из следующих языков. В каждом случае покажите корректность вашей грамматики

> а) Арифметические выражения в постфиксной записи

expression → number | expression expression operator | expression operator

Данная грамматика однозначна и контекстно-свободна. Успешно разбираются любые арифметические выражения в постфиксной записи, в которых используются операции сложения, вычитания, деления или умножения.
Например: 2 2 +; 2 2 + 5 *; 32 5 + 120 - и так далее

> б) Левоассоциативный список идентификаторов, разделенных запятыми

args -> args , identifier | identifier

> в) Правоассоциативный список идентификаторов, разделенных запятыми

args -> identifier , args | identifier

> г) Арифметические выражения, состоящие из целых чисел и идентификаторов с четырьмя бинарными операторами +, -, *, /.

expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> ident | number | ( expr )


> д) Добавьте унарные «плюс» и «минус» к арифметическим операторам из г

factor -> (+ | -) factor

## Упражнение 2.2.5

> а) Покажите, что все бинарные строки, генерируемые приведенной далее грамматикой, имеют значения, делящиеся на 3. Указание: воспользуйтесь индукцией по количеству узлов в дереве разбора

Пусть n - множество, содержащее позиции вхождения в строку всех строк «11», а множество m — множество, содержащее позиции вхождения в строку всех строк «1001». Позиции отсчитываются от least significant bit к most significant bit. Позицией вхождения многострочной строки является позиция вхождения ее первого символа.

Тогда сумма любой бинарной строки, генерируемой данной грамматикой, будет равна

```python
sum([(2^1 + 2^0) * 2**x for x in n]) + sum([(2^3 + 2^0) * 2**x for x in m]) = sum([3 * 2**x for x in n]) + sum([9 * 2**x for x in m])
```

Что очевидно делится на 3

> б) Генерирует ли эта грамматика все бинарные строки, значения которых делятся на 3?

Нет, например, данная грамматика не генерирует строку `10101`, значение которой делится на 3

## Упражнение 2.2.6

> Постройте контекстно-свободную грамматику для записи чисел римскими цифрами

romanNum -> thousand hundred ten digit
thousand -> M | MM | MMM | e
hundred -> smallHundred | CD | D smallHundred | CM
smallHundred -> C | CC | CCC | e
ten -> smallTen | XL | L smallTen | XC
smallTen -> X | XX | XXX | e
digit -> smallDigit | IV | V smallDigit | IX
smallDigit -> I | II | III | e